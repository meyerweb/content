---
title: Temporal.ZonedDateTime.prototype.with()
slug: Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime/with
tags:
  - Class
  - JavaScript
  - Time
---
{{JSRef}}

<p class="summary"><span class="seoSummary">The <strong><code>with()</code></strong> method returns a new <code>{{jsxref('Temporal.ZonedDateTime','Temporal.ZonedDateTime')}}</code> object which is a modification of the original object using new property values.</span>
</p>


<h2 id="syntax">Syntax</h2>

<pre class="brush: js">
with(<var>newValues</var>)
with(<var>newValues</var>, <var>options</var>)
</pre>

<h3 id="parameters">Parameters</h3>

<dl>
<dt><code><var>newValues</var></code></dt>
<dd>An object containing some of the properties accepted by <code>{{jsxref('Temporal/ZonedDateTime/from','Temporal.ZonedDateTime.from()')}}</code>.
<div class="note">
<strong>Note:</strong> <code>calendar</code> and <code>timeZone</code> properties are not allowed on <var>newValues</var>.  See the methods <code>{{jsxref('Temporal/ZonedDateTime/withCalendar','withCalendar()')}}</code> and <code>{{jsxref('Temporal/ZonedDateTime/withTimeZone','withTimeZone()')}}</code>.</p>
</div>
</dd>
<dt><code><var>options</var></code> {{optional_inline}}</dt>
<dd>
<p>An object containing properties that represent options for constructing the new <code>Temporal.ZonedDateTime</code> object. These are:</p>
<dl>
<dt><code>overflow</code></dt>
<dd>Determines how out-of-range values in <var>newValues</var> are handled.  There are two options:
<ul>
<li><code>'constrain'</code> <strong>(default)</strong> – Out-of-range values are clamped to the nearest in-range value.</li>
<li><code>'reject'</code> – Out-of-range values will cause the function to throw a <code>RangeError</code>.</li>
</ul>
</dd>
<dt><code>disambiguation</code></dt>
<dd><p>How to disambiguate if the date and time given by <code><var>dateTime</var></code> does not exist in the time zone, or exists more than once.  Allowed values are:</p>
<ul>
<li><code>'compatible'</code> <strong>(default)</strong> – Acts like <code>'earlier'</code> for backward transitions and <code>'later'</code> for forward transitions.</li>
<li><code>'earlier'</code> – The earlier of two possible times.</li>
<li><code>'later'</code> – The later of two possible times.</li>
<li><code>'reject'</code> – Throw a <code>RangeError</code> instead.</li>
</ul>
<p>When interoperating with existing code or services, <code>'compatible'</code> disambiguation matches the behavior of legacy {{jsxref('Date','Date')}} as well as libraries like moment.js, Luxon, and date-fns. This mode also matches the behavior of cross-platform standards like RFC 5545 (iCalendar).</p>

<div class="note">
<p><code>disambiguation</code> is only used if there is no offset in the input, or if the offset is ignored by using the <code>offset</code> option as described above. If the offset in the input is used, then there is no ambiguity and the <code>disambiguation</code> option is ignored.</p></dd>
</div>

<dt><code>offset</code></dt>
<dd><p>How to interpret a provided time zone offset (e.g., <code>-02:00</code>) if it conflicts with the provided time zone (e.g., <code>America/Sao_Paulo</code>).  Allowed values are:

<ul>
<li><code>'use'</code> – Evaluate date/time values using the time zone offset if it's provided in the input. This will keep the exact time unchanged even if local time will be different than what was originally stored.</li>
<li><code>'ignore'</code> – Never use the time zone offset provided in the input. Instead, calculate the offset from the time zone. This will keep local time unchanged but may result in a different exact time than was originally stored.</li>
<li><code>'prefer'</code> <strong>(default)</strong> – Evaluate date/time values using the offset if it's valid for this time zone. If the offset is invalid, then calculate the offset from the time zone.</li>
<li><code>'reject'</code> – Throw a <code>RangeError</code> if the offset is not valid for the provided date and time in the provided time zone.</li>
</ul>
<p>Unlike the <code>{{jsxref('Temporal.ZonedDateTime/from','.from()')}}</code> method where <code>offset</code> defaults to <code>'reject'</code>, the <code>offset</code> option in <code>.with()</code> defaults to <code>'prefer'</code>. This default prevents DST disambiguation from causing unexpected one-hour changes in exact time after making small changes to clock time fields.</p>
<p>For example, if a <code>{{jsxref('Temporal.ZonedDateTime','Temporal.ZonedDateTime')}}</code> is set to the "second" 1:30AM on a day where the 1-2AM clock hour is repeated after a backwards DST (Daylight Saving Time) transition, then calling <code>.with({minute: 45})</code> will result in an ambiguity which is resolved using the default <code>offset: 'prefer'</code> option. Because the existing offset is valid for the new time, it will be retained so the result will be the "second" 1:45AM. However, if the existing offset is not valid for the new result (e.g. <code>.with({hour: 0})</code>), then the default behavior will change the offset to match the new local time in that time zone.</p>
</dl>
</dd>
</dl>

<h3 id="return-value">Return value</h3>

<p>A new <code>{{jsxref('Temporal/ZonedDateTime','Temporal.ZonedDateTime')}}</code> object.  If the result is earlier or later than the range of dates <code>{{jsxref('Temporal.ZonedDateTime','Temporal.ZonedDateTime')}}</code> can represent (approximately half a million years centered on the Unix epoch), this method will throw a <code>RangeError</code> regardless of the value of <code>overflow</code>.</p>

<h2 id="examples">Examples</h2>

<pre class="brush: js">
zdt = Temporal.ZonedDateTime.from('1995-12-07T03:24:00-06:00[America/Chicago]');
zdt.with({ year: 2015, minute: 31 }); // => 2015-12-07T03:31:00-06:00[America/Chicago]
</pre>

<p>As noted previously, if a <code>timeZone</code> or <code>calendar</code> property is included in the <code>options</code> parameter, this function will throw an exception. To convert to a new time zone while updating the clock time, use the <code>{{jsxref('Temporal/ZonedDateTime/withTimeZone','.withTimeZone()')}}</code> method, and to keep clock time as-is while resetting the time zone, use the <code>{{jsxref('Temporal/ZonedDateTime/toPlainTime','.toPlainDateTime()')}}</code> method instead. Examples:</p>

<pre class="brush: js">
// update local time to match new time zone
const sameInstantInOtherTz = zdt.withTimeZone('Europe/London');
// create instance with same local time in a new time zone
const newTzSameLocalTime = zdt.toPlainDateTime().toZonedDateTime('Europe/London');
</pre>
