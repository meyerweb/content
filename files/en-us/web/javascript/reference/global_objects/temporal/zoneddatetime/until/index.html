---
title: Temporal.ZonedDateTime.until()
slug: Web/JavaScript/Reference/Global_Objects/Temporal/ZonedDateTime/until
tags:
  - Class
  - Date
  - Epoch
  - JavaScript
  - Time
  - Time Zone
  - Unix Epoch
  - timeStamp
---
{{JSRef}}

<p class="summary"><span class="seoSummary">The <strong><code>until()</code></strong> method computes the elapsed time from the date and time represented by <code>ZonedDateTime</code> until another date and time, optionally rounds it, and returns it as a <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object.</span>  If the second date and time is earlier than the first, then the resulting duration will be negative.  This method is similar to <code>{{jsxref('Temporal.ZonedDateTime/since','Temporal.ZonedDateTime.since()')}}</code>, but reversed.</p>

<p>The duration returned is a "hybrid" duration. This means that the duration's date portion represents full calendar days like <code>{{jsxref('Temporal.PlainDateTime/until','Temporal.PlainDateTime.until()')}}</code> would return, while its time portion represents real-world elapsed time like <code>{{jsxref('Temporal.Instant/until','Temporal.Instant.until()')}}</code> would return. This "hybrid duration" approach automatically adjusts for DST and matches widely-adopted industry standards like RFC 5545 (iCalendar). It also matches the behavior of popular JavaScript libraries like moment.js and date-fns.</p>

<p>Examples:</p>

<ul>
	<li>The difference between 2:30AM on the day before DST starts and 3:30AM on the day DST starts results in <code>P1DT1H</code>, even though it's only 24 hours of real-world elapsed time</li>
	<li>The difference between 1:45AM on the day before DST starts and the "second" 1:15AM on the day DST ends results in <code>PT24H30M</code> because it hasn't been a full calendar day even though it's been 24.5 real-world hours.</li>
</ul>

<div class="warning">
<p>Computing the difference between dates and times in different calendar systems is not supported.  If you need to do this, choose the calendar in which the computation takes place by converting one of the dates and times using the method <code>{{jsxref('Temporal.ZonedDateTime/withCalendar','.withCalendar()')}}</code>.</p>
</div>


<h2 id="syntax">Syntax</h2>

<pre class="brush: js">
until(<var>otherZonedDateTime</var>)
until(<var>otherZonedDateTime</var>, <var>options</var>)
</pre>

<h3 id="parameters">Parameters</h3>

<dl>
<dt><code><var>otherZonedDateTime</var></code></dt>
<dd>Another month as either a <code>{{jsxref('Temporal/ZonedDateTime','Temporal.ZonedDateTime')}}</code> object, or a value that can be converted to one as if passed to <code>{{jsxref('Temporal/ZonedDateTime.from()','Temporal.ZonedDateTime.from()')}}</code>.</dd>
<dt><code><var>options</var></code> {{optional_inline}}</dt>
<dd>
<p>An object with properties defining how the rounding operation should be carried out.  The allowed properties are:</p>
<dl>
<dt><code>largestUnit</code></dt>
<dd>A string defining the largest unit of time allowed in the returned object.  Valid values are:
<ul>
<li><code>'auto'</code> (default)</li>
<li><code>'years'</code></li>
<li><code>'months'</code></li>
<li><code>'weeks'</code></li>
<li><code>'days'</code></li>
<li><code>'hours'</code></li>
<li><code>'minutes'</code></li>
<li><code>'seconds'</code></li>
<li><code>'milliseconds'</code></li>
<li><code>'microseconds'</code></li>
<li><code>'nanoseconds'</code></li>
</ul>
<p>The <code>largestUnit</code> option controls how the resulting duration is expressed. A value of <code>'auto'</code> means <code>'hours'</code> unless the value of <code>smallestUnit</code> is <code>'years'</code>, <code>'months'</code>, <code>'weeks'</code>, or <code>'days'</code>, in which case <code>'auto'</code> means to match the value of <code>smallestUnit</code>.</p>
<p>The returned <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object will not have any nonzero fields that are larger than the unit in <code>largestUnit</code>. A difference of one year and two months will become 14 months when <code>largestUnit</code> is <code>'months'</code>, for example. However, a difference of one month will still be one month even if <code>largestUnit</code> is <code>'years'</code>.</p>
<div class="warning">
Take care when using <code>'milliseconds'</code>, <code>'microseconds'</code>, or <code>'nanoseconds'</code> as the largest unit. For some durations, the resulting value may overflow <code>{{jsxref('Number/MAX_SAFE_INTEGER','Number.MAX_SAFE_INTEGER')}}</code> and lose precision in its least significant digit(s). Nanoseconds values will overflow and lose precision after about 104 days. Microseconds can fit about 285 years without losing precision, and milliseconds can handle about 285,000 years without losing precision.
</div>
</dd>
<dt><code>smallestUnit</code></dt>
<dd>A string defining the smallest unit of time allowed in the returned object.  Valid values are the same as for <code>largestUnit</code>, except the default value is <code>'nanoseconds'</code>, which means no rounding will occur.</dd>
<dt><code>roundingIncrement</code></dt>
<dd>An integer defining the granularity of the rounding of the unit given by <code>smallestUnit</code>. The default is <code>1</code>.
<dt><code>roundingMode</code></dt>
<dd>
A string defining how to deal with any remainders. If <code>roundingMode</code> is not defined, then no rounding will be performed. The valid values are:
<dl>
<dt><code>'ceil'</code></dt>
<dd>Always round up, toward the end of time.</dd>
<dt><code>'floor'</code></dt>
<dt><code>'trunc'</code> (default)</dt>
<dd>Always round down, toward the beginning of time.  These two rounding modes behave identically, but are included for consistency with <code>{{jsxref('Temporal/Duration.round()','Temporal.Duration.round()')}}</code>, where they do <strong>not</strong> behave identically.</dd>
<dt><code>'halfExpand'</code></dt>
<dd>Round to the nearest of the values allowed by <code>roundingIncrement</code> and <code>smallestUnit</code>. If there is a tie, round up, toward the end of time.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<h3 id="return-value">Return value</h3>

<p>A new <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object representing the difference between the two dates and times.</p>

<h2 id="examples">Examples</h2>

<pre class="brush: js">
zdt1 = Temporal.ZonedDateTime.from('1995-12-07T03:24:30.000003500+05:30[Asia/Kolkata]');
zdt2 = Temporal.ZonedDateTime.from('2019-01-31T15:30+05:30[Asia/Kolkata]');
zdt1.until(zdt2);
  // => PT202956H5M29.9999965S
zdt1.until(zdt2, { largestUnit: 'years' });
  // => P23Y1M24DT12H5M29.9999965S
zdt2.until(zdt1, { largestUnit: 'years' });
  // => -P23Y1M24DT12H5M29.9999965S
zdt1.until(zdt2, { largestUnit: 'nanoseconds' });
  // => PT730641929.999996544S
  // (precision lost)

// Rounding, for example if you don't care about sub-seconds
zdt1.until(zdt2, { smallestUnit: 'seconds' });
  // => PT202956H5M29S

// Months and years can be different lengths
[jan1, feb1, mar1] = [1, 2, 3].map((month) =>
  Temporal.ZonedDateTime.from({ year: 2020, month, day: 1, timeZone: 'Asia/Seoul' })
);
jan1.until(feb1, { largestUnit: 'days' }); // => P31D
jan1.until(feb1, { largestUnit: 'months' }); // => P1M
feb1.until(mar1, { largestUnit: 'days' }); // => P29D
feb1.until(mar1, { largestUnit: 'months' }); // => P1M
jan1.until(mar1, { largestUnit: 'days' }); // => P60D
</pre>
