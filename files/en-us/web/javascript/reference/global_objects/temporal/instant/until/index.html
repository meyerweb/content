---
title: Temporal.Instant.prototype.until()
slug: Web/JavaScript/Reference/Global_Objects/Temporal/Instant/until
tags:
  - Class
  - Date
  - Epoch
  - JavaScript
  - Time
  - Time Zone
  - Unix Epoch
  - timeStamp
---
{{JSRef}}

<p>The <strong><code>until()</code></strong> method computes the elapsed time from the exact time represented by <code>instant</code> until the exact time represented by <code><var>moment</var></code>, optionally rounds it, and returns it as a <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object.If <code><var>moment</var></code> is earlier than <Code>instant</code>, then the resulting duration will be negative.  This method is similar to <code>{{jsxref('Temporal.Instant/since','Temporal.Instant.since()')}}</code>, but reversed.</p>
<p>By default, the largest unit in the result is seconds. Weeks, months, years, and days are not allowed, unlike the difference methods of the other Temporal types. This is because months and years can be different lengths depending on which month is meant, and whether the year is a leap year, which all depends on the start and end date of the difference. You cannot determine the start and end date of a difference between <code>{{jsxref('Temporal/Instant','Temporal.Instant')}}</code>s, because <code>{{jsxref('Temporal/Instant','Temporal.Instant')}}</code> has no time zone or calendar. In addition, weeks can be different lengths in different calendars, and days can be different lengths when the time zone has a daylight saving transition.</p>
<p>If you do need to calculate the difference between two <code>{{jsxref('Temporal/Instant','Temporal.Instant')}}</code>s in years, months, weeks, or days, then you can make an explicit choice on how to eliminate this ambiguity, choosing your starting point by converting to a <code>{{jsxref('Temporal/PlainDateTime','Temporal.PlainDateTime')}}</code> or <code>{{jsxref('Temporal/ZonedDateTime','Temporal.ZonedDateTime')}}</code>. For example, you might decide to base the calculation on your user's current time zone, or on UTC, in the Gregorian calendar.</p>


<h2 id="syntax">Syntax</h2>

<pre class="brush: js">
until(<var>moment</var>)
until(<var>moment</var>, <var>options</var>)
</pre>

<h3 id="parameters">Parameters</h3>

<dl>
<dt><code><var>moment</var></code></dt>
<dd>An exact time as either a <code>{{jsxref('Temporal/Instant','Temporal.Instant')}}</code> object, or a value that can be converted to one as if passed to <code>{{jsxref('Temporal/Instant.from()','Temporal.Instant.from()')}}</code>.</dd>
<dt><code><var>options</var></code> {{optional_inline}}</dt>
<dd>
<p>An object with properties defining how the rounding operation should be carried out.  The allowed properties are:</p>
<dl>
<dt><code>largestUnit</code></dt>
<dd>A string defining the largest unit of time allowed in the returned object.  Valid values are:
<ul>
<li><code>'auto'</code> (default)</li>
<li><code>'hours'</code></li>
<li><code>'minutes'</code></li>
<li><code>'seconds'</code></li>
<li><code>'milliseconds'</code></li>
<li><code>'microseconds'</code></li>
<li><code>'nanoseconds'</code></li>
</ul>
<p>The <code>largestUnit</code> option controls how the resulting duration is expressed. A value of <code>'auto'</code> means <code>'seconds'</code>, unless <code>smallestUnit</code> is <code>'hours'</code> or <code>'minutes'</code>, in which case <code>largestUnit</code> is equal to <code>smallestUnit</code>.</p>
<p> The returned <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object will not have any nonzero fields that are larger than the unit in <code>largestUnit</code>. A difference of two hours will become 7200 seconds when <code>largestUnit</code> is <code>'seconds'</code>, for example. However, a difference of 30 seconds will still be 30 seconds even if <code>largestUnit</code> is <code>'hours'</code>.</p>
<p>Take care when using milliseconds, microseconds, or nanoseconds as the largest unit. For some durations, the resulting value may overflow <code>Number.MAX_SAFE_INTEGER</code> and lose precision in its least significant digit(s). Nanoseconds values will overflow and lose precision after about 104 days. Microseconds can fit about 285 years without losing precision, and milliseconds can handle about 285,000 years without losing precision.</p>
</dd>
<dt><code>smallestUnit</code></dt>
<dd>A string defining the smallest unit of time allowed in the returned object.  Valid values are the same as for <code>largestUnit</code>.</dd>
<dt><code>roundingIncrement</code></dt>
<dd>An integer defining the granularity of the rounding of the unit given by <code>smallestUnit</code>. The default is <code>1</code>.
<dt><code>roundingMode</code></dt>
<dd>
A string defining how to deal with any remainders. If <code>roundingMode</code> is not defined, then no rounding will be performed. The valid values are:
<dl>
<dt><code>'ceil'</code></dt>
<dd>Always round up, toward the end of time.</dd>
<dt><code>'floor'</code></dt>
<dt><code>'trunc'</code> (default)</dt>
<dd>Always round down, toward the beginning of time.  These two rounding modes behave identically, but are included for consistency with <code>{{jsxref('Temporal/Duration.round()','Temporal.Duration.round()')}}</code>, where they do <strong>not</strong> behave identically.</dd>
<dt><code>'halfExpand'</code></dt>
<dd>Round to the nearest of the values allowed by <code>roundingIncrement</code> and <code>smallestUnit</code>. If there is a tie, round up, toward the end of time.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<h3 id="return-value">Return value</h3>

<p>A new <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object representing the difference between <code>instant</code> and <code><var>moment</var></code>.</p>

<h2 id="examples">Examples</h2>

<pre class="brush: js">
startOfMoonMission = Temporal.Instant.from('1969-07-16T13:32:00Z');
endOfMoonMission = Temporal.Instant.from('1969-07-24T16:50:35Z');
missionLength = startOfMoonMission.until(endOfMoonMission, { largestUnit: 'days' });
  // => PT195H18M35S
missionLength.toLocaleString();
  // example output: '195 hours 18 minutes 35 seconds'

// Rounding, for example if you don't care about the minutes and seconds
approxMissionLength = startOfMoonMission.until(endOfMoonMission, {
  largestUnit: 'hours',
  smallestUnit: 'hours'
});
  // => P195H

// A billion (10^9) seconds since the epoch in different units
epoch = Temporal.Instant.fromEpochSeconds(0);
billion = Temporal.Instant.fromEpochSeconds(1e9);
epoch.until(billion);
  // =>    PT1000000000S
epoch.until(billion, { largestUnit: 'hours' });
  // =>  PT277777H46M40S
ns = epoch.until(billion, { largestUnit: 'nanoseconds' });
  // =>    PT1000000000S
ns.add({ nanoseconds: 1 });
  // =>    PT1000000000S (lost precision)

// Calculate the difference in years, eliminating the ambiguity by
// explicitly using the corresponding calendar date in UTC:
epoch.toZonedDateTimeISO('UTC').until(
  billion.toZonedDateTimeISO('UTC'),
  { largestUnit: 'years' }
);
  // => P31Y8M8DT1H46M40S</pre>
