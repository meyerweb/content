---
title: Temporal.PlainDateTime.prototype.until()
slug: Web/JavaScript/Reference/Global_Objects/Temporal/PlainDateTime/until
tags:
  - Class
  - Date
  - Epoch
  - JavaScript
  - Time
  - Time Zone
  - Unix Epoch
  - timeStamp
---
{{JSRef}}

<p>The <strong><code>until()</code></strong> method computes the elapsed time from the date and time represented by <code><var>dateTime</var></code> until another date and time, optionally rounds it, and returns it as a <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object.If the second date and time is earlier than the first, then the resulting duration will be negative.  This method is similar to <code>{{jsxref('Temporal.PlainDateTime/since','Temporal.PlainDateTime.since()')}}</code>, but reversed.</p>
<div class="warning">
<p><strong>Warning:</strong> Computing the difference between dates and times in different calendar systems is not supported.  If you need to do this, choose the calendar in which the computation takes place by converting one of the dates and times using the method <code>{{jsxref('Temporal.PlainDateTime/withCalendar','withCalendar()')}}</code>.</p>
</div>


<h2 id="syntax">Syntax</h2>

<pre class="brush: js">
until(<var>otherDateTime</var>)
until(<var>otherDateTime</var>, <var>options</var>)
</pre>

<h3 id="parameters">Parameters</h3>

<dl>
<dt><code><var>otherDateTime</var></code></dt>
<dd>Another month as either a <code>{{jsxref('Temporal/PlainDateTime','Temporal.PlainDateTime')}}</code> object, or a value that can be converted to one as if passed to <code>{{jsxref('Temporal/PlainDateTime.from()','Temporal.PlainDateTime.from()')}}</code>.</dd>
<dt><code><var>options</var></code> {{optional_inline}}</dt>
<dd>
<p>An object with properties defining how the rounding operation should be carried out.  The allowed properties are:</p>
<dl>
<dt><code>largestUnit</code></dt>
<dd>A string defining the largest unit of time allowed in the returned object.  Valid values are:
<ul>
<li><code>'auto'</code> (default)</li>
<li><code>'years'</code></li>
<li><code>'months'</code></li>
<li><code>'weeks'</code></li>
<li><code>'days'</code></li>
<li><code>'hours'</code></li>
<li><code>'minutes'</code></li>
<li><code>'seconds'</code></li>
<li><code>'milliseconds'</code></li>
<li><code>'microseconds'</code></li>
<li><code>'nanoseconds'</code></li>
</ul>
<p>The <code>largestUnit</code> option controls how the resulting duration is expressed. A value of <code>'auto'</code> means <code>'days'</code> unless the value of <code>smallestUnit</code> is <code>'years'</code>, <code>'months'</code>, or <code>'weeks'</code>, in which case <code>'auto'</code> means to match the value of <code>smallestUnit</code>.</p>
<p>The returned <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object will not have any nonzero fields that are larger than the unit in <code>largestUnit</code>. A difference of one year and two months will become 14 months when <code>largestUnit</code> is <code>'months'</code>, for example. However, a difference of one month will still be one month even if <code>largestUnit</code> is <code>'years'</code>.</p>
<div class="warning">
<p><strong>Warning:</strong> Take care when using <code>'milliseconds'</code>, <code>'microseconds'</code>, or <code>'nanoseconds'</code> as the largest unit. For some durations, the resulting value may overflow <code>{{jsxref('Number/MAX_SAFE_INTEGER','Number.MAX_SAFE_INTEGER')}}</code> and lose precision in its least significant digit(s). Nanoseconds values will overflow and lose precision after about 104 days. Microseconds can fit about 285 years without losing precision, and milliseconds can handle about 285,000 years without losing precision.</p>
</div>
</dd>
<dt><code>smallestUnit</code></dt>
<dd>A string defining the smallest unit of time allowed in the returned object.  Any fraction of time smaller than this will be rounded to the smallest unit.  Valid values are the same as for <code>largestUnit</code>, except the default value is <code>'nanoseconds'</code>, which means no rounding will occur.</dd>
<dt><code>roundingIncrement</code></dt>
<dd>An integer defining the granularity of the rounding of the unit given by <code>smallestUnit</code>. The default is <code>1</code>.
<dt><code>roundingMode</code></dt>
<dd>
A string defining how to deal with any remainders. If <code>roundingMode</code> is not defined, then no rounding will be performed. The valid values are:
<dl>
<dt><code>'ceil'</code></dt>
<dd>Always round up, toward the end of time.</dd>
<dt><code>'floor'</code></dt>
<dt><code>'trunc'</code> (default)</dt>
<dd>Always round down, toward the beginning of time.  These two rounding modes behave identically, but are included for consistency with <code>{{jsxref('Temporal/Duration.round()','Temporal.Duration.round()')}}</code>, where they do <strong>not</strong> behave identically.</dd>
<dt><code>'halfExpand'</code></dt>
<dd>Round to the nearest of the values allowed by <code>roundingIncrement</code> and <code>smallestUnit</code>. If there is a tie, round up, toward the end of time.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>


<h3 id="return-value">Return value</h3>

<p>A new <code>{{jsxref('Temporal/Duration','Temporal.Duration')}}</code> object representing the difference between the two dates and times.</p>

<h2 id="examples">Examples</h2>

<pre class="brush: js">
dt1 = Temporal.PlainDateTime.from('1995-12-07T03:24:30.000003500');
dt2 = Temporal.PlainDateTime.from('2019-01-31T15:30');
dt1.until(dt2);
  // => P8456DT12H5M29.9999965S
dt1.until(dt2, { largestUnit: 'years' });
  // => P23Y1M24DT12H5M29.9999965S
dt2.until(dt1, { largestUnit: 'years' });
  // => -P23Y1M24DT12H5M29.9999965S
dt1.until(dt2, { largestUnit: 'nanoseconds' });
  // => PT730641929.999996544S
  // (precision lost)

// Rounding, for example if you don't care about sub-seconds
dt1.until(dt2, { smallestUnit: 'seconds' });
  // => P8456DT12H5M29S

// Months and years can be different lengths
let [jan1, feb1, mar1] = [1, 2, 3].map((month) =>
  Temporal.PlainDateTime.from({ year: 2020, month, day: 1 }));
jan1.until(feb1);                            // => P31D
jan1.until(feb1, { largestUnit: 'months' }); // => P1M
feb1.until(mar1);                            // => P29D
feb1.until(mar1, { largestUnit: 'months' }); // => P1M
jan1.until(mar1);                            // => P60D
</pre>
